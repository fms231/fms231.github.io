<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Elasticsearch</title>
      <link href="/%E6%A1%86%E6%9E%B6/ES/elasticsearch/4126151966e1/"/>
      <url>/%E6%A1%86%E6%9E%B6/ES/elasticsearch/4126151966e1/</url>
      
        <content type="html"><![CDATA[<h1 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h1><ul><li>支持分布式，可水平扩展</li><li>提供Restful接口，可被任何语言调用<br>使用的是倒排索引<br>文档 document：每条数据就是一个文档<br>词条 term：文档按照语义分成的词语</li></ul><h2 id="IK分词器"><a href="#IK分词器" class="headerlink" title="IK分词器"></a>IK分词器</h2><p>it_smart：智能分词器，中文分词<br>ik_max_word：细粒度分词器，中文分词</p><p>可以扩展分词器词库汇总的词条，利用config目录的IkAnalyzer.cfg.xml文件，往里面配置自己的扩展词典</p><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>索引：相当类型的文档的集合，相当于数据库中的表<br>映射：索引中文档的字段约束信息，类似于表的结构约束<br>映射属性：</p><ul><li>type：字段类型<ul><li>字符串：text、keyword</li><li>数值：long、integer、short、byte、double、float</li><li>日期：date</li><li>布尔：boolean</li><li>对象：object</li></ul></li><li>analyzer：分词器</li><li>index：是否索引</li><li>properties：子字段<br>邮箱使用keyword，数组只用指定元素的类型</li></ul><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>创建索引库和mapping的请求语法如下：<br>新增</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">PUT /索引库名称</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;field1&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_max_word&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;field2&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;field3&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;subfield1&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">PUT /fms231</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;info&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span> </span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_smart&quot;</span><span class="punctuation">,</span> </span><br><span class="line">        <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;byte&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;object&quot;</span><span class="punctuation">,</span> </span><br><span class="line">        <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;firstName&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;lastName&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>查询</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /索引库名称</span><br><span class="line">GET /索引库名称/_doc/文档id</span><br></pre></td></tr></table></figure><p>删除</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE /索引库名称</span><br><span class="line">DELETE /索引库名称/_doc/文档id</span><br></pre></td></tr></table></figure><p>索引库和mapping一旦创建，就不能修改字段，但是可以添加新的字段</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">PUT /索引库名称/_mapping</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;field4&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全量修改，会删除就文档，添加新文档</span></span><br><span class="line">PUT /索引库名称/_doc/文档id</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;field1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;value1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;field2&quot;</span><span class="punctuation">:</span> <span class="string">&quot;value2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;field3&quot;</span><span class="punctuation">:</span> <span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 增量修改，只修改指定字段</span></span><br><span class="line">POST /索引库名称/_update/文档id</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;doc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;field1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;value1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;field2&quot;</span><span class="punctuation">:</span> <span class="string">&quot;value2&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;field3&quot;</span><span class="punctuation">:</span> <span class="string">&quot;value3&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>增量修改可以指定全部字段，也可以指定部分字段</p><p>新增文档</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /索引库名称/_doc/文档id</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;field1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;value1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;field2&quot;</span><span class="punctuation">:</span> <span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>批量处理</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST /_bulk</span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;_index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;索引库名称&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;文档id&quot;</span> <span class="punctuation">&#125;</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;field1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;value1&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;field2&quot;</span><span class="punctuation">:</span> <span class="string">&quot;value2&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;_index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;索引库名称&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;文档id&quot;</span> <span class="punctuation">&#125;</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;field1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;value1&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;field2&quot;</span><span class="punctuation">:</span> <span class="string">&quot;value2&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;delete&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;_index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;索引库名称&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;文档id&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;update&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;_index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;索引库名称&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;文档id&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;doc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;field1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;value1&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;field2&quot;</span><span class="punctuation">:</span> <span class="string">&quot;value2&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="JavaRestClient"><a href="#JavaRestClient" class="headerlink" title="JavaRestClient"></a>JavaRestClient</h2><p>索引库基本操作</p><ol><li>创建xxxIndexRequest</li><li>准备请求参数</li><li>发送请求 xxx.indices().create&#x2F;delete</li></ol><p>文档基本操作<br>新增文档</p><ol><li>IndexRequest request &#x3D; new IndexRequest(“索引库名称”).id(“文档id”)</li><li>request.source(“{}”, XContentType.JSON)</li><li>client.index(request, RequestOptions.DEFAULT)<br>删除<br>client.delete(new DeleteRequest(“索引库名称”, “文档id”), RequestOptions.DEFAULT)<br>查询<br>client.get(new GetRequest(“索引库名称”, “文档id”), RequestOptions.DEFAULT)<br>修改<br>全量更新</li><li>IndexRequest request &#x3D; new IndexRequest(“索引库名称”).id(“文档id”)</li><li>request.source(“{}”, XContentType.JSON)</li><li>client.index(request, RequestOptions.DEFAULT)<br>局部更新<br>client.update(new UpdateRequest(“索引库名称”, “文档id”).doc(“{}”, XContentType.JSON), RequestOptions.DEFAULT)</li></ol><p>批量处理</p><ol><li>BulkRequest request &#x3D; new BulkRequest()</li><li>request.add(new IndexRequest(“索引库名称”).id(“文档id”).source(“{}”, XContentType.JSON))</li><li>request.add(new DeleteRequest(“索引库名称”, “文档id”))</li></ol><h2 id="DSL查询"><a href="#DSL查询" class="headerlink" title="DSL查询"></a>DSL查询</h2><h3 id="叶子查询"><a href="#叶子查询" class="headerlink" title="叶子查询"></a>叶子查询</h3><p>一般是在特定的字段里查询特定值，属于简单查询，很少单独使用</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /索引库名称/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;查询类型&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;查询条件&quot;</span><span class="punctuation">:</span> <span class="string">&quot;查询值&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>全文检索（full text） <ul><li>match查询 {“match” : {“field”: “value”} }  在一个字段中查询</li><li>multi_match查询 { “multi_match” : “fields”: [“field1”, “field2”], “query”: “value”}  在多个字段中查询</li></ul></li><li>精确查询 <ul><li>term { “term”: { “field”: “value” } }</li><li>range { “range”: { “field”: { “gte”: 10, “lte”: 20 } } }  价格或者日期</li></ul></li><li>地理查询 { “geo_distance”: { “distance”: “10km”, “location”: { “lat”: 40, “lon”: -70 } } }</li></ul><h3 id="复合查询"><a href="#复合查询" class="headerlink" title="复合查询"></a>复合查询</h3><p>以逻辑方式组合多个叶子查询或者更改叶子查询的行为方式</p><ul><li><p>第一类 逻辑运算组合叶子查询</p><ul><li>bool<ul><li>must 必须匹配每个子查询 与</li><li>should 选择性匹配子查询 或</li><li>must_not 必须不匹配，不参与算分 非</li><li>filter 必须匹配，不参与算分</li></ul></li></ul></li><li><p>基于某种算法修改查询时的文档相关性算法</p><ul><li>function_score</li><li>dis_max</li></ul></li></ul><p>在查询之后，还可以对查询结果进行排序、分页、高亮和聚合等操作</p><h3 id="排序和分页"><a href="#排序和分页" class="headerlink" title="排序和分页"></a>排序和分页</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /索引库名称/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span> <span class="attr">&quot;字段&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="string">&quot;asc&quot;</span> <span class="punctuation">&#125;</span> <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">10</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="高亮"><a href="#高亮" class="headerlink" title="高亮"></a>高亮</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET /索引库名称/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;字段&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;highlight&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;字段&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p>聚合可以实现对文档数据的统计、分析、运算。聚合常见的有三类：</p><ul><li>桶聚合，用来对文档做分组</li><li>度量聚合，用来计算一些值，Avg、Stats（同时求max、min、avg、sum）、Max、Min</li><li>管道聚合，其他聚合的结果为基础做聚合<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET /索引库名称/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;聚合名称&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;聚合类型&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;字段&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池</title>
      <link href="/Java/JUC/ThreadPool/5f07901ac9d7/"/>
      <url>/Java/JUC/ThreadPool/5f07901ac9d7/</url>
      
        <content type="html"><![CDATA[<h1 id="线程池的Tips"><a href="#线程池的Tips" class="headerlink" title="线程池的Tips"></a>线程池的Tips</h1><p>ThreadPoolExecutor的参数列表</p><ul><li>int corePoolSize：核心线程数</li><li>int maximumPoolSize：最大线程数</li><li>long keepAliveTime：线程空闲时间</li><li>TimeUnit unit：时间单位</li><li>BlockingQueue workQueue：阻塞队列</li><li>ThreadFactory threadFactory：线程工厂</li><li>RejectedHandler handler：拒绝策略</li></ul><p>动态参数设置</p><ul><li>ThreadPoolExecutor.setCorePoolSize(int corePoolSize)</li><li>ThreadPoolExecutor.setMaximumPoolSize(int maximumPoolSize)</li><li>ThreadPoolExecutor.setKeepAliveTime(long time, TimeUnit unit)</li><li>ThreadPoolExecutor.setThreadFactory(ThreadFactory threadFactory)</li><li>ThreadPoolExecutor.setRejectedExecutionHandler(RejectedExecutionHandler handler)</li><li>allowCoreThreadTimeOut(boolean value)：允许核心线程超时，默认为false，即核心线程不会超时</li></ul><p>线程池的状态获取</p><ul><li>getCorePoolSize()：获取核心线程数</li><li>getMaximumPoolSize()：获取最大线程数</li><li>getPoolSize()：获取当前线程数</li><li>getActiveCount()：获取活动线程数</li><li>getTaskCount()：获取任务总数</li><li>getCompletedTaskCount()：获取已完成任务数</li></ul><p>线程预热<br>ThreadPoolExecutor默认状态是通过execute方法提交一个任务后，来创建工作线程执行，创建线程需要一定的启动成本，需要提升运行时间，最后ThreadPoolExecutor提供线程预热：</p><ul><li>prestartCoreThread()：预热一个核心线程</li><li>prestartAllCoreThreads()：预热所有核心线程<br>预热核心线程，因为Max线程需要依赖BlockingQueue的状态</li></ul><p>可观测性<br>Java Thread状态</p><p>Java ThreadPoolExecutor状态</p><p>SPI</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring</title>
      <link href="/%E6%A1%86%E6%9E%B6/Spring/spring/4044216b3bd2/"/>
      <url>/%E6%A1%86%E6%9E%B6/Spring/spring/4044216b3bd2/</url>
      
        <content type="html"><![CDATA[<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><p>横切关注点，从每个方法中抽取出来的同一类非核心业务<br>切面 Aspect， 对横切关注点进行封装的类，每个关注点体现为一个通知方法，通常使用@Aspect注解来定义切面<br>通知 Advice，切面必须要完成的各个具体工作，如前置通知@Before、后置通知@After、环绕通知@Around、异常通知@AfterThrowing、最终通知@AfterReturning<br>连接点 JoinPoint，通知应用的时机，比如接口方法被调用时就是日志切面的连接点<br>切点 Pointcut，通知功能被应用的范围</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>技术平台</title>
      <link href="/%E9%A1%B9%E7%9B%AE/project/tech/90baf2b297ab/"/>
      <url>/%E9%A1%B9%E7%9B%AE/project/tech/90baf2b297ab/</url>
      
        <content type="html"><![CDATA[<h1 id="技术平台"><a href="#技术平台" class="headerlink" title="技术平台"></a>技术平台</h1><p>用户角色：读者、作者、管理员<br>权限：管理员&gt;作者&gt;读者</p><ul><li>读者的所有功能，作者都拥有；但是作者存在部分读者用不了的功能（如文章编辑、修改、发布等）</li><li>管理员权限最大，覆盖读者、作者的所有功能点</li></ul><p>读者主要是阅读文章<br>作者主要是发布文章<br>管理员主要是管理整个系统，标签、文章审核、分类管理等，通常不参与文章的阅读发布</p><h1 id="业务拆分"><a href="#业务拆分" class="headerlink" title="业务拆分"></a>业务拆分</h1><ul><li>用户</li><li>文章</li><li>专栏</li><li>消息</li><li>评论</li><li>运营</li><li>搜索</li><li>推荐</li><li>统计</li></ul><h1 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h1><p>用户首先通过用户中心登录系统<br>具体的登录方式可以是传统的用户名&#x2F;密码，也可以是手机号验证码，亦或者是第三方OAuth2.0登录<br>登录之后，用户身份识别，可以是单机的cookie&#x2F;session, 也可以是分布式会话，jwt等形式</p><h1 id="消息通知方案"><a href="#消息通知方案" class="headerlink" title="消息通知方案"></a>消息通知方案</h1><p>消息通知采用异步驱动，通过Event&#x2F;Listener方式来实现解耦</p><h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p>使用MCV三层架构，是模型（Model）、视图（View）和控制器（Controller）的缩写，可以分为三层：表示层、业务逻辑层和数据访问层</p><h1 id="实体对象"><a href="#实体对象" class="headerlink" title="实体对象"></a>实体对象</h1><p>do 领域对象<br>dto 数据传输对象<br>bo 业务对象<br>po 持久化对象<br>vo 视图对象<br>req 请求参数对象<br>rsp 返回参数对象</p><h1 id="生成traceid"><a href="#生成traceid" class="headerlink" title="生成traceid"></a>生成traceid</h1><p>规则：服务器IP（16进制） + 时间戳（毫秒时间戳）+ 自增序列（1000-9999循环） + 当前进程（保证5位）<br>为什么需要traceid：在分布式系统中，一个请求可能会经过多个服务，为了追踪一个请求的整个调用链路，需要一个唯一的标识</p><h1 id="MdcUtil"><a href="#MdcUtil" class="headerlink" title="MdcUtil"></a>MdcUtil</h1><p>上下文诊断映射，用于在多线程环境中存储每个线程特定的诊断信息</p><h1 id="用户活跃度"><a href="#用户活跃度" class="headerlink" title="用户活跃度"></a>用户活跃度</h1><p>分为日&#x2F;月两个榜单<br>活跃度计算：</p><ul><li>用户每访问一个新的页面，活跃度+1</li><li>对于一篇文章，点赞、收藏 +2，取消点赞、取消收藏，将之前的活跃度收回</li><li>文章评论 +3</li><li>发布一篇审核通过文章 +10</li></ul><p>减少活跃度，防止扣减为负数<br>榜单展示活跃度最高的前三十名用户</p><h1 id="用户审核"><a href="#用户审核" class="headerlink" title="用户审核"></a>用户审核</h1><p>白名单中的用户发文之后，无需审核，直接发布</p><h1 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h1><p>监听器实现实时人数统计</p><h1 id="PV和UV"><a href="#PV和UV" class="headerlink" title="PV和UV"></a>PV和UV</h1><p>page view：页面浏览量<br>unique visitor：独立访客数<br>使用百度的站点统计功能</p><h1 id="导出数据"><a href="#导出数据" class="headerlink" title="导出数据"></a>导出数据</h1><p>Fast Excel实现PU&#x2F;UV数据的批量导出功能，500w数据导出时间仅需1分钟，并结合线程池和CountDownLatch进行并发处理，导出性能提升近60倍</p><h1 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h1><p>先写数据库，再删除缓存</p><ol><li>不缓存非热点数据</li><li>更新次数比查询次数高的也不用缓存</li><li>对数据一致性要求极高的也不用缓存</li></ol>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> project </tag>
            
            <tag> tech </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯</title>
      <link href="/%E7%AE%97%E6%B3%95/algorithm/backtracing/68fc7d433ce4/"/>
      <url>/%E7%AE%97%E6%B3%95/algorithm/backtracing/68fc7d433ce4/</url>
      
        <content type="html"><![CDATA[<h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><p>leetcode 2597. 美丽子集的数目<br>给你一个由正整数组成的数组<code>nums</code>，和一个正整数<code>k</code>。<br>如果<code>nums</code>中子集中，任意两个整数的绝对差均不等于<code>k</code>，则认为该子数组是一个<code>美丽</code>子集。<br>返回数组<code>nums</code>中<code>非空</code>且<code>美丽</code>的子集数目。<br><code>nums</code>的子集定义为：可以经由<code>nums</code>删除某些元素（也可能不删除）得到的一个数组。只有在删除元素时选择的索引不同的情况下，两个子集才会被视作是不同的子集。</p><mark class="hl-label red">思路：</mark><mark class="hl-label pink">由于题目要求子集中任意两个整数的绝对差均不等于k，我们可以使用回溯算法来枚举所有的子集，然后判断是否满足条件。每个元素都是选或不选，如果不选则继续往前，如果选该元素，则需要判断是否有元素与该元素构成绝对差等于k，如果有，则不能选，反之，则可以选</mark><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">beautifulSubsets</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="comment"># 去除空集的情况</span></span><br><span class="line">    ans = -<span class="number">1</span></span><br><span class="line">    <span class="comment"># 使用哈希加快判断速度</span></span><br><span class="line">    cnt = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="comment"># 所有元素都遍历完了</span></span><br><span class="line">        <span class="keyword">if</span> i == n:</span><br><span class="line">            <span class="keyword">nonlocal</span> ans</span><br><span class="line">            ans += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 不选当前元素</span></span><br><span class="line">        dfs(i+<span class="number">1</span>)  </span><br><span class="line">        <span class="comment"># 选当前元素，判断是否满足条件     </span></span><br><span class="line">        <span class="keyword">if</span> cnt[nums[i] - k] == <span class="number">0</span> <span class="keyword">and</span> cnt[nums[i] + k] == <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 选择当前元素，更新哈希表</span></span><br><span class="line">            cnt[nums[i]] += <span class="number">1</span></span><br><span class="line">            dfs(i+<span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 回溯</span></span><br><span class="line">            cnt[nums[i]] -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    dfs(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前缀和</title>
      <link href="/%E7%AE%97%E6%B3%95/algorithm/prefixSum/644395af4204/"/>
      <url>/%E7%AE%97%E6%B3%95/algorithm/prefixSum/644395af4204/</url>
      
        <content type="html"><![CDATA[<h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><p>假设有一个从零开始的数组<code>nums</code>，长度为n，我们可以通过计算前缀和数组<code>prefixSum</code>来快速计算任意区间<code>[i,j]</code>的和。</p><p>前缀和数组<code>prefixSum</code>的定义如下：<br>prefixSum[i] &#x3D; nums[0] + nums[1] + … + nums[i-1]<br>即prefixSum[i] &#x3D; prefixSum[i-1] + nums[i-1]<br>其中prefixSum[0] &#x3D; 0</p><p>有了上面的定义，我们可以快速计算任意区间<code>[i,j]</code>的和：<br>sum[i,j] &#x3D; prefixSum[j+1] - prefixSum[i]</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>leetcode 560. 和为K的子数组<br>给定一个整数数组和一个整数k，找到该数组中和为k的连续子数组的个数。</p><mark class="hl-label red">思路：</mark><mark class="hl-label pink">由于是连续非空子数组，我们可以使用前缀和数组来计算任意区间的和，然后通过判断prefixSum[j+1]-prefixSum[i]==k来判断是否存在和为k的子数组，由于题目限制时间，可以通过哈希表来记录之前前缀和出现的次数，从而加快计算</mark><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">subarraySum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="comment"># 初始值为0</span></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 哈希表记录 （前缀和，出现次数）</span></span><br><span class="line">    cnt = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">    <span class="comment"># 前缀和，初始化为0</span></span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 定义前缀和为0的情况，出现一次</span></span><br><span class="line">    cnt[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="comment"># 遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="comment"># 计算前缀和</span></span><br><span class="line">        s += num</span><br><span class="line">        <span class="comment"># 如果存在前缀和为s-k的情况，且当前前缀和为s，也就是存在一个区间[i,j]，使得sum[i,j] = k，那么就统计上这个区间</span></span><br><span class="line">        ans += cnt[s - k]</span><br><span class="line">        <span class="comment"># 更新前缀和为s的情况</span></span><br><span class="line">        cnt[s] += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> prefixSum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPC</title>
      <link href="/project/project/rpc/d0862aa570a7/"/>
      <url>/project/project/rpc/d0862aa570a7/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ul><li>RPC（Remote Procedure Call）远程过程调用，是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议</li></ul><h1 id="代理层"><a href="#代理层" class="headerlink" title="代理层"></a>代理层</h1><p>代理层用于封装多余的操作，例如：制定协议，编码，从注册中心要服务，负载均衡，调用，容错机制。所有的流程都在代理层封装好了，调用方只需要进行调用方法即可。</p><h1 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h1>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rpc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tips</title>
      <link href="/uncategorized/JVM/Tips/91762032956a/"/>
      <url>/uncategorized/JVM/Tips/91762032956a/</url>
      
        <content type="html"><![CDATA[<h1 id="RoaringBitmap"><a href="#RoaringBitmap" class="headerlink" title="RoaringBitmap"></a>RoaringBitmap</h1><p>内存占用相比List少了50倍</p><h1 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h1><ol><li>首先表态如果使用合理的JVM参数配置，在大多数情况应该是不需要调优的</li><li>其次说明可能还是存在少量场景需要调优，我们可以对一些JVM核心指标配置监控告警，当出现波动时认为介入分析评估</li><li>最后举一个实际的调优例子来加以说明</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Stream</title>
      <link href="/Java/Java/Stream/f6f23f5e7773/"/>
      <url>/Java/Java/Stream/f6f23f5e7773/</url>
      
        <content type="html"><![CDATA[<h1 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h1><p>用于操作集合或者数组的数据<br>Stream流大量的结合了lambda的语法风格来编程，提供了一种更加强大，更佳简单的方式操作集合或者数组中的数据，代码更简洁，可读性更好</p><ul><li><strong>声明式编程</strong>：通过链式调用描述操作，而不是通过循环实现。</li><li><strong>惰性求值</strong>：中间操作不会立即执行，只有在终端操作触发时才会执行。</li><li><strong>并行支持</strong>：可以轻松地将串行流转换为并行流，利用多核 CPU 提高性能。</li></ul><h1 id="数据源"><a href="#数据源" class="headerlink" title="数据源"></a>数据源</h1><p>Stream 的数据源可以是集合、数组、I&#x2F;O 资源等。</p><h1 id="中间方法"><a href="#中间方法" class="headerlink" title="中间方法"></a>中间方法</h1><p>中间操作是对 Stream 的转换操作，返回一个新的 Stream。<br>常见的中间操作：</p><ul><li>filter(Predicate<T>)：过滤元素。</li><li>map(Function&lt;T, R&gt;)：将元素映射为另一种类型。</li><li>sorted()：对元素排序。</li><li>distinct()：去重。</li></ul><h1 id="终结方法"><a href="#终结方法" class="headerlink" title="终结方法"></a>终结方法</h1><p>终端操作会触发 Stream 的执行，并生成最终结果。<br>常见的终端操作：</p><ul><li>forEach(Consumer<T>)：对每个元素执行操作。</li><li>collect(Collector&lt;T, A, R&gt;)：将 Stream 转换为集合。</li><li>reduce(BinaryOperator<T>)：将 Stream 归约为一个值。</li><li>count()：返回 Stream 中元素的数量。</li></ul><h1 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h1><h2 id="创建-Stream"><a href="#创建-Stream" class="headerlink" title="创建 Stream"></a>创建 Stream</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过集合创建 Stream</span></span><br><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C++&quot;</span>);</span><br><span class="line">Stream&lt;String&gt; stream = list.stream();</span><br><span class="line"><span class="comment">// 通过数组创建 Stream</span></span><br><span class="line">String[] array = &#123;<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C++&quot;</span>&#125;;</span><br><span class="line">Stream&lt;String&gt; stream = Arrays.stream(array);</span><br><span class="line"><span class="comment">// 通过 Stream.of() 创建 Stream</span></span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C++&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="过滤操作"><a href="#过滤操作" class="headerlink" title="过滤操作"></a>过滤操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; result = list.stream()</span><br><span class="line">                          .filter(s -&gt; s.startsWith(<span class="string">&quot;J&quot;</span>))</span><br><span class="line">                          .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h2 id="映射操作"><a href="#映射操作" class="headerlink" title="映射操作"></a>映射操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; lengths = list.stream()</span><br><span class="line">                            .map(String::length)</span><br><span class="line">                            .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h2 id="排序操作"><a href="#排序操作" class="headerlink" title="排序操作"></a>排序操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; sorted = list.stream()</span><br><span class="line">                          .sorted()</span><br><span class="line">                          .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h2 id="去重操作"><a href="#去重操作" class="headerlink" title="去重操作"></a>去重操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; distinct = list.stream()</span><br><span class="line">                            .distinct()</span><br><span class="line">                            .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h2 id="归约操作"><a href="#归约操作" class="headerlink" title="归约操作"></a>归约操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; result = list.stream()</span><br><span class="line">                              .reduce((s1, s2) -&gt; s1 + <span class="string">&quot;, &quot;</span> + s2);</span><br></pre></td></tr></table></figure><h2 id="收集操作"><a href="#收集操作" class="headerlink" title="收集操作"></a>收集操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; result = list.stream()</span><br><span class="line">                          .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h1 id="并行操作"><a href="#并行操作" class="headerlink" title="并行操作"></a>并行操作</h1><p>并行流，通过<code>parallelStream()</code>方法将集合转换为并行流，可以充分利用多核 CPU 提高性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C++&quot;</span>);</span><br><span class="line">list.parallelStream().forEach(System.out::println);</span><br></pre></td></tr></table></figure><ul><li>并行流并不总是比串行流快，对于小数据集合，串行流可能更高效。</li><li>并行流的操作需要保证线程安全。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Stream </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Map</title>
      <link href="/Java/%E9%9B%86%E5%90%88/Map/e943314c546f/"/>
      <url>/Java/%E9%9B%86%E5%90%88/Map/e943314c546f/</url>
      
        <content type="html"><![CDATA[<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>双列集合，键值对集合<br>key不重复，value可以重复</p><h2 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h2><ul><li><code>put(K key, V value)</code> 添加元素</li><li><code>get(Object key)</code> 根据key获取value</li><li><code>remove(Object key)</code> 根据key删除元素</li><li><code>containsKey(Object key)</code> 是否包含指定的key</li><li><code>containsValue(Object value)</code> 是否包含指定的value</li><li><code>size()</code> 集合大小</li><li><code>isEmpty()</code> 是否为空</li><li><code>clear()</code> 清空集合</li><li><code>keySet()</code> 获取所有的key</li><li><code>values()</code> 获取所有的value</li><li><code>entrySet()</code> 获取所有的键值对</li></ul><h2 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h2><p>for (String key:map.keySet()) {}<br>for (Map.Entry&lt;String, String&gt; entry:map.entrySet()) {}<br>map.forEach((k, v) -&gt; {});</p><p>以下的Map底层原理和Set的一样，只是多了一个value的存储</p><h2 id="HashMap-集合的底层原理"><a href="#HashMap-集合的底层原理" class="headerlink" title="HashMap 集合的底层原理"></a>HashMap 集合的底层原理</h2><p>无序、不重复、无索引<br>基于哈希表实现的，</p><h2 id="LinkedHashMap-集合的底层原理"><a href="#LinkedHashMap-集合的底层原理" class="headerlink" title="LinkedHashMap 集合的底层原理"></a>LinkedHashMap 集合的底层原理</h2><p>有序、不重复、无索引</p><h2 id="TreeMap-集合的底层原理"><a href="#TreeMap-集合的底层原理" class="headerlink" title="TreeMap 集合的底层原理"></a>TreeMap 集合的底层原理</h2><p>按照大小默认升序排序、不重复、无索引。只能对key进行排序，不能对value进行排序</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Map </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Set</title>
      <link href="/Java/%E9%9B%86%E5%90%88/Set/e33b5cb5bb6c/"/>
      <url>/Java/%E9%9B%86%E5%90%88/Set/e33b5cb5bb6c/</url>
      
        <content type="html"><![CDATA[<p>哈希值：一个int类型的数值，Java中每个对象都有一个哈希值，调用hashCode()方法可以获取对象的哈希值。<br>同一个对象多次调用hashCode()方法返回的哈希值是相同的，不同对象的哈希值可能相同(哈希碰撞)</p><h1 id="HashSet-集合的底层原理"><a href="#HashSet-集合的底层原理" class="headerlink" title="HashSet 集合的底层原理"></a>HashSet 集合的底层原理</h1><p>基于哈希表实现，哈希表是一种增删改查数据，性能都较好的数据结构<br>jdk8之前：HashSet的底层原理，基于哈希表：数组+链表组成</p><ol><li>创建一个默认长度为16的数组，默认加载因子0.75</li><li>使用元素的哈希值对数组长度取模，得到存储位置</li><li>如果该位置没有元素，则直接存储</li><li>如果该位置有元素，则调用equals()方法比较哈希值和元素是否相同，如果相同则不存储，如果不同则存储（jdk 8 之前，新元素存入数组，占老元素的位置，老元素挂在新元素下面， jdk 8 之后，新元素直接挂在老元素下面）</li></ol><mark class="hl-label red">如果数组快占满了，会出现什么问题，该怎么办?</mark><br /><mark class="hl-label pink">如果数组快占满了，则会导致链表过长，导致查询性能降低。此时哈希表会扩容，一单占有的元素个数超过了数组长度*加载因子，则会扩容为原来的2倍，并将原来的元素重新存储到新的数组中。如果链表过长，而数组没有占满，在jdk8之后，当链表长度超过8，且数组长度>=64时，自动将链表转为红黑树（数组还在），以提高查询性能。</mark><p>jdk8之后：HashSet的底层原理，基于哈希表：数组+链表+红黑树</p><h2 id="HashSet去重机制"><a href="#HashSet去重机制" class="headerlink" title="HashSet去重机制"></a>HashSet去重机制</h2><p>无序、不重复、无索引</p><ol><li>先调用元素的hashCode()方法，得到元素的哈希值</li><li>通过哈希值计算出元素在数组中的存储位置</li><li>判断该位置是否有元素</li><li>如果没有元素，则直接存储</li><li>如果有元素，则调用equals()方法比较哈希值和元素是否相同，<strong>如果相同则不存储（去重）</strong>，如果不同则存储<br>如果认为类中内容一样的元素是重复的，则需要重写hashCode()和equals()方法</li></ol><h1 id="LinkedHashSet-集合的底层原理"><a href="#LinkedHashSet-集合的底层原理" class="headerlink" title="LinkedHashSet 集合的底层原理"></a>LinkedHashSet 集合的底层原理</h1><p>有序、不重复、无索引<br>基于哈希表实现的（数组+链表+红黑树）<br>但是每个元素都额外的多了一个双向链表的机制，用来维护元素的添加顺序<br>内存消耗比HashSet大</p><h1 id="TreeSet-集合的底层原理"><a href="#TreeSet-集合的底层原理" class="headerlink" title="TreeSet 集合的底层原理"></a>TreeSet 集合的底层原理</h1><p>不重复、无索引、可排序（默认升序排序，按照元素大小，由小到大排序）<br>如果认为第一个元素比第二个元素大时，则需要返回正数，<br>如果认为第一个元素比第二个元素小时，则需要返回负数，<br>如果认为第一个元素和第二个元素相等，则返回0<br>底层是通过红黑树进行排序<br>TreeSet集合存储自定义类型的对象时，必须指定排序规则，支持如下两种方式来指定排序规则：</p><ol><li>让自定义的类实现Comparable接口，重写里面的compareTo方法来指定比较规则</li><li>通过调用TreeSet集合有参构造器，可以设置Comparator&lt;&gt;对象（比较器对象，用于指定比较规则）</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Collection </tag>
            
            <tag> Set </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>List</title>
      <link href="/Java/%E9%9B%86%E5%90%88/List/1e8ab4034216/"/>
      <url>/Java/%E9%9B%86%E5%90%88/List/1e8ab4034216/</url>
      
        <content type="html"><![CDATA[<h1 id="ArrayList-集合的底层原理"><a href="#ArrayList-集合的底层原理" class="headerlink" title="ArrayList 集合的底层原理"></a>ArrayList 集合的底层原理</h1><p>有序、可重复、有索引<br>基于数组实现，查询速度快（根据索引查）、删除效率低、添加效率极低<br>创建过程：利用无参构造器创建ArrayList对象时，会创建一个默认长度为0的空数组。当第一次添加元素时，底层会创建一个长度为10的数组，并将第一个元素添加到数组中。存满之后，会扩容1.5倍，如果一次添加多个元素，1.5倍还放不下，则新创建数组的长度以实际为准</p><h1 id="LinkedList-集合的底层原理"><a href="#LinkedList-集合的底层原理" class="headerlink" title="LinkedList 集合的底层原理"></a>LinkedList 集合的底层原理</h1><p>有序、可重复、有索引<br>基于双链表实现，查询速度慢（根据索引查）、增删效率较高、对首尾元素进行增删改查的速度是极快的。<br>可以实现队列、设计栈</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> List </tag>
            
            <tag> Collection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合</title>
      <link href="/Java/%E9%9B%86%E5%90%88/%E9%9B%86%E5%90%88/81672bbce2e0/"/>
      <url>/Java/%E9%9B%86%E5%90%88/%E9%9B%86%E5%90%88/81672bbce2e0/</url>
      
        <content type="html"><![CDATA[<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>Java 集合框架（Java Collections Framework）是 Java 标准库中用于存储和操作数据的重要部分。它提供了一套丰富的接口和实现类，帮助开发者高效地处理数据集合。<br>主要分为两组：单列集合、双列集合</p><ul><li>单列集合：Collection接口的子接口，存储一个元素集合</li><li>双列集合：Map接口的子接口，存储键值对</li></ul><p>Java 集合框架的核心接口位于 <code>java.util</code> 包中，主要包括：</p><ul><li><code>Collection</code>：所有集合类的根接口。</li><li><code>List</code>：有序集合，允许重复元素。</li><li><code>Set</code>：无序集合，不允许重复元素。</li><li><code>Map</code>：键值对集合，键不允许重复。</li></ul><h1 id="核心接口"><a href="#核心接口" class="headerlink" title="核心接口"></a>核心接口</h1><h2 id="（1）Collection-接口"><a href="#（1）Collection-接口" class="headerlink" title="（1）Collection 接口"></a>（1）<code>Collection</code> 接口</h2><p><code>Collection</code> 是所有集合类的根接口，定义了集合的基本操作，如添加、删除、遍历等。<br>常用方法：</p><ul><li><code>add(E e)</code>：添加元素。</li><li><code>remove(Object o)</code>：删除元素。</li><li><code>size()</code>：返回集合大小。</li><li><code>iterator()</code>：返回迭代器。</li></ul><h2 id="（2）List-接口"><a href="#（2）List-接口" class="headerlink" title="（2）List 接口"></a>（2）<code>List</code> 接口</h2><p><code>List</code> 是有序集合，允许重复元素。它扩展了 <code>Collection</code> 接口，提供了按索引访问元素的功能。<br>常用实现类：</p><ul><li><code>ArrayList</code>：基于动态数组实现，适合随机访问。</li><li><code>LinkedList</code>：基于双向链表实现，适合频繁插入和删除。<br>常用方法：</li><li><code>get(int index)</code>：获取指定位置的元素。</li><li><code>set(int index, E element)</code>：设置指定位置的元素。</li><li><code>add(int index, E element)</code>：在指定位置插入元素。</li></ul><h2 id="（3）Set-接口"><a href="#（3）Set-接口" class="headerlink" title="（3）Set 接口"></a>（3）<code>Set</code> 接口</h2><p><code>Set</code> 是无序集合，不允许重复元素。它扩展了 <code>Collection</code> 接口。<br>常用实现类：</p><ul><li><code>HashSet</code>：基于哈希表实现，元素无序。</li><li><code>TreeSet</code>：基于红黑树实现，元素有序。<br>常用方法：</li><li><code>add(E e)</code>：添加元素（如果元素已存在，则不会添加）。</li><li><code>contains(Object o)</code>：判断集合是否包含指定元素。</li></ul><h2 id="（4）Map-接口"><a href="#（4）Map-接口" class="headerlink" title="（4）Map 接口"></a>（4）<code>Map</code> 接口</h2><p><code>Map</code> 是键值对集合，键不允许重复。它不继承 <code>Collection</code> 接口。<br>常用实现类：</p><ul><li><code>HashMap</code>：基于哈希表实现，键值对无序。</li><li><code>TreeMap</code>：基于红黑树实现，键值对有序。<br>常用方法：</li><li><code>put(K key, V value)</code>：添加键值对。</li><li><code>get(Object key)</code>：根据键获取值。</li><li><code>keySet()</code>：返回所有键的集合。</li></ul><h1 id="常用实现类"><a href="#常用实现类" class="headerlink" title="常用实现类"></a>常用实现类</h1><p>（1）<code>ArrayList</code></p><ul><li><strong>特点</strong>：基于动态数组实现，支持快速随机访问。</li><li><strong>底层原理</strong>：<ul><li><code>ArrayList</code>内部使用一个 <code>Object[]</code> 数组来存储元素。</li><li>当数组容量不足时，会自动扩容（通常是当前容量的 1.5 倍）。</li><li>由于基于数组实现，<code>ArrayList</code> 的随机访问时间复杂度为 O(1)，但插入和删除操作的时间复杂度为 O(n)。</li></ul></li><li><strong>适用场景</strong>：适合查询操作较多的场景。</li><li><strong>示例</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;Python&quot;</span>);</span><br><span class="line">System.out.println(list.get(<span class="number">0</span>)); <span class="comment">// 输出: Java</span></span><br></pre></td></tr></table></figure>（2）<code>LinkedList</code></li><li><strong>特点</strong>：基于双向链表实现，支持快速插入和删除。</li><li><strong>底层原理</strong>：<ul><li><code>LinkedList</code>内部使用一个双向链表来存储元素。</li><li>每个节点包含前驱指针、后继指针和元素值。</li><li>由于基于链表实现，LinkedList 的插入和删除操作时间复杂度为 O(1)，但随机访问时间复杂度为 O(n)。</li></ul></li><li><strong>适用场景</strong>：适合频繁插入和删除的场景。</li><li><strong>示例</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">list.add(<span class="number">1</span>, <span class="string">&quot;Python&quot;</span>); <span class="comment">// 在索引 1 处插入元素</span></span><br><span class="line">System.out.println(list); <span class="comment">// 输出: [Java, Python]</span></span><br></pre></td></tr></table></figure>（3）<code>HashSet</code></li><li><strong>特点</strong>：基于哈希表实现，元素无序，不允许重复。</li><li><strong>底层原理</strong>：<ul><li><code>HashSet</code>内部使用 HashMap 来存储元素。</li><li>元素作为 HashMap 的键，值是一个固定的 Object 对象。</li><li>通过哈希算法确定元素的存储位置，查找、插入和删除操作的时间复杂度为 O(1)。</li></ul></li><li><strong>适用场景</strong>：适合需要快速查找和去重的场景。</li><li><strong>示例</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">set.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;Python&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;Java&quot;</span>); <span class="comment">// 重复元素不会被添加</span></span><br><span class="line">System.out.println(set); <span class="comment">// 输出: [Java, Python]</span></span><br></pre></td></tr></table></figure>（4）<code>TreeSet</code></li><li><strong>特点</strong>：基于红黑树实现，元素有序，不允许重复。</li><li><strong>底层原理</strong>：<ul><li>TreeSet 内部使用 TreeMap 来存储元素。</li><li>元素作为 TreeMap 的键，值是一个固定的 Object 对象。</li><li>通过红黑树实现元素的排序，查找、插入和删除操作的时间复杂度为 O(log n)。</li></ul></li><li><strong>适用场景</strong>：适合需要有序集合的场景。</li><li><strong>示例</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">set.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;Python&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;C++&quot;</span>);</span><br><span class="line">System.out.println(set); <span class="comment">// 输出: [C++, Java, Python]</span></span><br></pre></td></tr></table></figure>（5）<code>HashMap</code></li><li><strong>特点</strong>：基于哈希表实现，键值对无序，键不允许重复。</li><li><strong>底层原理</strong>：<ul><li><code>HashMap</code>部使用一个 Node&lt;K,V&gt;[] 数组来存储键值对。</li><li>通过哈希算法确定键的存储位置，解决哈希冲突的方法是链地址法（JDK 8 之后，当链表长度超过阈值时会转换为红黑树）。</li><li>查找、插入和删除操作的时间复杂度为 O(1)。</li></ul></li><li><strong>适用场景</strong>：适合需要快速查找键值对的场景。</li><li><strong>示例</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;Java&quot;</span>, <span class="number">1</span>);</span><br><span class="line">map.put(<span class="string">&quot;Python&quot;</span>, <span class="number">2</span>);</span><br><span class="line">System.out.println(map.get(<span class="string">&quot;Java&quot;</span>)); <span class="comment">// 输出: 1</span></span><br></pre></td></tr></table></figure>（6）<code>TreeMap</code></li><li><strong>特点</strong>：基于红黑树实现，键值对有序，键不允许重复。</li><li><strong>底层原理</strong>：<ul><li><code>TreeMap</code>内部使用红黑树来存储键值对。</li><li>红黑树是一种自平衡的二叉搜索树，确保查找、插入和删除操作的时间复杂度为 O(log n)。</li><li>键值对按照键的自然顺序或自定义比较器排序。</li></ul></li><li><strong>适用场景</strong>：适合需要有序键值对的场景。</li><li><strong>示例</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;Java&quot;</span>, <span class="number">1</span>);</span><br><span class="line">map.put(<span class="string">&quot;Python&quot;</span>, <span class="number">2</span>);</span><br><span class="line">map.put(<span class="string">&quot;C++&quot;</span>, <span class="number">3</span>);</span><br><span class="line">System.out.println(map); <span class="comment">// 输出: &#123;C++=3, Java=1, Python=2&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="集合工具类"><a href="#集合工具类" class="headerlink" title="集合工具类"></a>集合工具类</h1><p>Java 提供了<code>Collections</code>工具类，用于对集合进行操作，如排序、查找、反转等。<br>常用方法：</p><ul><li>sort(List<T> list)：对列表进行排序。</li><li>reverse(List&lt;?&gt; list)：反转列表。</li><li>shuffle(List&lt;?&gt; list)：随机打乱列表。</li></ul><h1 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h1><ol><li>for循环<br>适合<code>List</code>这种有序集合，可以根据索引遍历。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;Python&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;C++&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    System.out.println(list.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>迭代器<br>适合所有实现了 Iterable 接口的集合（如 List、Set）。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;Python&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;C++&quot;</span>);</span><br><span class="line"></span><br><span class="line">Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">item</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    System.out.println(item);</span><br><span class="line">    <span class="comment">// 可以在遍历时删除元素</span></span><br><span class="line">    <span class="keyword">if</span> (item.equals(<span class="string">&quot;Python&quot;</span>)) &#123;</span><br><span class="line">        iterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>增强for循环<br>适合所有实现了 Iterable 接口的集合（如 List、Set）。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;Python&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;C++&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String item : list) &#123;</span><br><span class="line">    System.out.println(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>lambda表达式：forEach<br>适合需要简洁语法的场景，尤其是结合 Lambda 表达式使用。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;Python&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;C++&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Lambda 表达式</span></span><br><span class="line">list.forEach(item -&gt; System.out.println(item));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方法引用</span></span><br><span class="line">list.forEach(System.out::println);</span><br></pre></td></tr></table></figure></li><li>使用Stream遍历<br>适合需要对集合进行过滤、映射、排序等操作。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;Python&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;C++&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Stream 遍历并过滤</span></span><br><span class="line">list.stream()</span><br><span class="line">    .filter(item -&gt; item.startsWith(<span class="string">&quot;J&quot;</span>))</span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure></li></ol><h1 id="集合并发修改异常"><a href="#集合并发修改异常" class="headerlink" title="集合并发修改异常"></a>集合并发修改异常</h1><p>通常发生在使用迭代器遍历集合时，同时对集合进行结构性修改（如添加、删除元素）。<br>异常名称：<code>ConcurrentModificationException</code><br>触发条件：在迭代器遍历集合时，同时对集合进行结构性修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;Python&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;C++&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String item : list) &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.equals(<span class="string">&quot;Python&quot;</span>)) &#123;</span><br><span class="line">        list.remove(item); <span class="comment">// 抛出 ConcurrentModificationException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方法：</p><ul><li>使用迭代器的 <code>remove</code> 方法删除元素。</li><li>使用<code>CopyOnWriteArrayList</code>类，它是线程安全的，支持并发读写。</li><li>使用<code>Collections.synchronizedList</code>方法，将集合转换为线程安全的集合。</li><li>使用Stream过滤集合</li></ul><h1 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h1><p><code>格式</code>：数据类型… 参数名称</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span>... nums)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以不传数据，也可以传一个或多个数据，也可以传一个数组给它，常常用来灵活的接受数据</p><ul><li><strong>可变参数在方法内部，本质是一个数组。</strong></li><li><strong>一个形参列表中，只能有一个可变参数</strong></li><li><strong>可变参数必须放在形参列表的最后一个位置</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高性能收集器</title>
      <link href="/Java/JVM/%E9%AB%98%E6%80%A7%E8%83%BD%E6%94%B6%E9%9B%86%E5%99%A8/98c3da5ef3fc/"/>
      <url>/Java/JVM/%E9%AB%98%E6%80%A7%E8%83%BD%E6%94%B6%E9%9B%86%E5%99%A8/98c3da5ef3fc/</url>
      
        <content type="html"><![CDATA[<h1 id="分区收集器-G1、ZGC、Shenandoah"><a href="#分区收集器-G1、ZGC、Shenandoah" class="headerlink" title="分区收集器 G1、ZGC、Shenandoah"></a>分区收集器 G1、ZGC、Shenandoah</h1><div class="timeline pink"><div class='timeline-item headline'>        <div class='timeline-item-title'>          <div class='item-circle'><p>GC体系的变化</p></div>        </div>      </div><div class='timeline-item'>        <div class='timeline-item-title'>          <div class='item-circle'><p>2018-09</p></div>        </div>        <div class='timeline-item-content'><p>JDK11发布，引入<code>Epsilon</code>垃圾回收器，又被称为<code>&quot;No-0p（无操作） &quot;</code>回收器。同时，引入了可伸缩的低延迟垃圾回收器<code>ZGC（Experimental）</code>。</p></div>      </div><div class='timeline-item'>        <div class='timeline-item-title'>          <div class='item-circle'><p>2019-03</p></div>        </div>        <div class='timeline-item-content'><p>JDK12发布，增强<code>G1</code>收集器，实现自动返还未用堆内存给操作系统。同时，引入了低停顿时间的收集器<code>ShenandoahGC（Experimental）</code>。</p></div>      </div><div class='timeline-item'>        <div class='timeline-item-title'>          <div class='item-circle'><p>2019-09</p></div>        </div>        <div class='timeline-item-content'><p>JDK13发布，增强<code>ZGC</code>收集器，实现自动返还未用堆内存给操作系统。</p></div>      </div><div class='timeline-item'>        <div class='timeline-item-title'>          <div class='item-circle'><p>2020-03</p></div>        </div>        <div class='timeline-item-content'><p>JDK14发布，剔除了<code>CMS</code>收集器，同时扩展<code>ZGC</code>在macOS和Windows上的应用，增强<code>G1</code>支持<code>NUMA</code>架构。</p></div>      </div></div><h1 id="开创GC“分区回收”-G1-Garbage-First-Garbage-Collector（垃圾优先收集器）"><a href="#开创GC“分区回收”-G1-Garbage-First-Garbage-Collector（垃圾优先收集器）" class="headerlink" title="开创GC“分区回收” - G1 Garbage-First Garbage Collector（垃圾优先收集器）"></a>开创GC“分区回收” - G1 Garbage-First Garbage Collector（垃圾优先收集器）</h1><p>G1收集器将堆空间划分为“物理分区不分代”的内存结构<br>G1收集器的特性：</p><ul><li>与CMS收集器一样，能够与用户线程同时执行，完成并发收集</li><li>GC过程会有整理内存的过程，不会产生内存碎片，并且整理空闲内存速度更快</li><li>GC发生时，停顿时间可控，可以让程序更大程度上追求低延迟</li><li>追求低延迟的同时，尽可能会保证高吞吐量</li><li>对于堆的未使用内存可以返还给操作系统</li></ul><p>每个分区可能是年轻代也可能是老年代，但是在同一时刻只能属于某个代。在运行时，每个分区都会被打上唯一的分区标示。<br>不过在G1收集器中，年轻代Eden区，幸存区Survivor、老年代Old区这些概念依旧还存在，但却成为了逻辑上的概念，好处在于：可以复用之前分代框架的逻辑，同时也满足了Java对象<code>朝生夕死</code>的特性<br>在G1收集器中，内存空间会被划分为一个个的Region区，这样JVM不需要再为堆空间分配连续的内存，堆空间可以是不连续物理内存来组成的Region的集合。同时，有的Region区内垃圾对象特别多，有的分区内垃圾对象很少，G1可以优先回收垃圾对象特别多的Region区，这样可以花费较少的时间来回收垃圾，这也就是G1名字的由来，即垃圾优先收集器。<br>G1将Java堆划分为多个大小相等的独立的Region区域，不过在HotSpot的源码TARGET_REGION_NUMBER定义了Region区的数量限制为2048个（实际上允许超过这个值，但是超过这个数量后，堆空间会变的难以管理）。<br>G1中的年老代晋升条件和之前的无差，达到年龄阈值的对象会被转入年老代的Region区中，不同的是对于大对象的分配，在G1中不会让大对象进入年老代，在G1中由专门存放大对象的Region区叫做Humongous区，如果在分配对象时，判定出一个对象属于大对象，那么则会直接将其放入Humongous区存储。<br>在G1中，判定一个对象是否为大对象的方式为：对象大小是否超过单个普通Region区的50%，如果超过则代表当前对象为大对象，那么该对象会被直接放入Humongous区。比如：目前是8GB的堆空间，每个Region区的大小为4MB，当一个对象大小超过2MB时则会被判定为属于大对象。如果程序运行过程中出现一个“巨型对象”，当一个Humongous区存不下时，可能会横跨多个Region区存储它。<br>Humongous区存在的意义：可以避免一些“短命”的巨型对象直接进入年老代，节约年老代的内存空间，可以有效避免年老代因空间不足时的GC开销。<br>当堆空间发生全局GC(FullGC)时，除开回收新生代和年老代之外，也会对Humongous区进行回收。</p><p>G1中新生代初始化为堆内存的5%，最大是占用堆内存的60%。Eden区中的对象有95%以上都熬不过一个垃圾回收。</p><h2 id="G1收集器GC类型"><a href="#G1收集器GC类型" class="headerlink" title="G1收集器GC类型"></a>G1收集器GC类型</h2><h3 id="YoungGC"><a href="#YoungGC" class="headerlink" title="YoungGC"></a>YoungGC</h3><p>YoungGC并非说Eden区放满了就会立马被触发，在G1中，当新生代区域被用完时，G1首先会大概计算一下回收当前的新生代空间需要花费多少时间，如果回收时间远远小于参数-XX:MaxGCPauseMills设定的值，那么不会触发YoungGC，而是会继续为新生代增加新的Region区用于存放新分配的对象实例。直至某次Eden区空间再次被放满并经过计算后，此次回收的耗时接近-XX:MaxGCPauseMills参数设定的值，那么才会触发YoungGC。<br>G1收集器中的新生代收集，依旧保留了分代收集器的特性，当YoungGC被触发时，首先会将目标Region区中的存活对象移动至幸存区空间（被打着Survivor-from区标志的Region）。同时达到晋升年龄标准的对象也会被移入至年老代Region中存储。<br>G1收集器在发生YoungGC时，复制移动对象时是采用的多线程并行复制，以此来换取更优异的GC性能。用户如若未曾显式通过-XX:MaxGCPauseMills参数设定GC预期回收停顿时间值，那么G1默认为200ms。</p><h3 id="MixedGC"><a href="#MixedGC" class="headerlink" title="MixedGC"></a>MixedGC</h3><p>MixedGC翻译过来的意思为混合型GC，而并非是指FullGC。当整个堆中年老代的区域占有率达到参数-XX:InitiatingHeapOccupancyPercent设定的值后触发MixedGC，发生该类型GC后，会回收所有新生代Region区、部分年老代Region区（会根据期望的GC停顿时间选择合适的年老代Region区优先回收）以及大对象Humongous区。<br>正常情况下，G1垃圾收集时会先发生MixedGC，主要采用复制算法，在GC时先将要回收的Region区中存活的对象拷贝至别的Region区内，拷贝过程中，如果发现没有足够多的空闲Region区承载拷贝对象，此时就会触发一次Full GC</p><h3 id="FullGC"><a href="#FullGC" class="headerlink" title="FullGC"></a>FullGC</h3><p>当整个堆空间中的空闲Region不足以支撑拷贝对象或由于元数据空间满了等原因触发，在发生FullGC时，G1首先会停止系统所有用户线程，然后采用单线程进行标记、清理和压缩整理内存，以便于清理出足够多的空闲Region来供下一次MixedGC使用。但该过程是单线程串行收集的，因此这个过程非常耗时的(ShenandoahGC中采用了多线程并行收集)。</p><h2 id="G1收集器垃圾回收过程"><a href="#G1收集器垃圾回收过程" class="headerlink" title="G1收集器垃圾回收过程"></a>G1收集器垃圾回收过程</h2><ol><li>初始标记InitialMark：先触发STW，然后使用单条GC线程快速标记<strong>GCRoots</strong>直连的对象。</li><li>并发标记ConcurrentMarking：与CMS的并发标记过程一致，采用多条GC线程与用户线程共同执行，根据Root根节点标记所有对象</li><li>最终标记Remark：同CMS的重新标记阶段，主要是为了纠正并发标记阶段因用户操作导致的<strong>错标、误标、漏标对象</strong></li><li>筛选回收Cleanup：先对各个Region区的回收价值会成本进行排序，找出<code>回收价值最大</code>的Region优先回收</li></ol><p>G1收集器正是由于「筛选回收」阶段的存在，所以才得以冠名「垃圾优先收集器」。在该阶段中，对各个Region区排序后，G1会根据用户指定的期望停顿时间（即-XX:MaxGCPauseMillis参数设定的值）选择「价值最大且最符合用户预期」的Region区进行回收</p><mark class="hl-label pink">假设此时年老代空间共有800个Region区，并且都满了，所以此刻会触发GC。但根据GC的预期停顿时间值，本次GC只能允许停顿200ms，而G1经过前面的成本计算后，大致可推断出：本次GC回收600个Region区恰好停顿时间可控制在200ms左右，那么最终就会以「回收600个Region区」为基准触发GC，这样则能尽量确保GC导致的停顿时间可以被控制在我们指定的范围之内。</mark><p><strong>筛选回收阶段在G1收集器中是会停止所有用户线程后，采用多线程并行回收的。但实际上这个过程中可以与用户线程一起执行做到并发收集的，但因为G1只回收一部分Region区，停顿时间是可控的，因此停止用户线程后回收效率会大幅度提高。</strong><br>但自G1开始，包括之后的ZGC、ShenandoahGC收集器，从每个Region区角度看来是采用的复制算法，但从堆空间整体看来，则是采用了标-整算法，这也是所谓的“局部复制，全局标-整”。这两种算法无论是那种都不会造成内存碎片产生，带来的好处是：在为大对象进行内存分配时，不会因为找不到连续的内存空间提前触发下一次GC，有利于程序长期运行，尤其是在大内存情况下的堆空间，带来的优势额外明显。<br>不过在内存较小的堆空间情况下，CMS的表现会优于G1收集器，平衡点在6~8GB左右。</p><h2 id="G1中的三色标记-漏标问题解决方案剖析"><a href="#G1中的三色标记-漏标问题解决方案剖析" class="headerlink" title="G1中的三色标记-漏标问题解决方案剖析"></a>G1中的三色标记-漏标问题解决方案剖析</h2><p>CMS收集器拉开了并发收集的新序幕，而并发收集的核心在于三色标记算法，但三色标记又注定着会出现漏标问题。<br>G1收集器中解决三色算法漏标问题的手段：<code>STAB + 写屏障</code>。</p><h3 id="STAB-snapshot-at-the-beginning"><a href="#STAB-snapshot-at-the-beginning" class="headerlink" title="STAB (snapshot at the beginning)"></a>STAB (snapshot at the beginning)</h3><p>存在的意义是为了维护G1收集器GC-并发收集的正确性。保证存活的对象不被回收，保证回收的都是垃圾。如果是独占式收集，也就是发生STW后串行回收的方式，那GC时能够确保100%的正确性，但如若收集过程是与用户线程并发执行的，GC线程一边标记，用户线程一边执行，因而堆中的对象引用会存在变更，出现不稳定因素，最终导致标记的正确性无法得到保障。而为了解决该问题，在G1收集器中则引入了STAB机制。</p><h3 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h3><h1 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h1><p>无论是逻辑上还是物理上都不在保留分代的概念</p><p>在ZGC中，也会把堆空间划分为一个个的Region区域，但ZGC中的Region区不存在分代的概念，它仅仅只是简单的将所有Region区分为了大、中、小三个等级<br>小型区&#x2F;页(Small)：固定大小为2MB，用于分配小于256KB的对象。<br>中型区&#x2F;页(Medium)：固定大小为32MB，用于分配&gt;&#x3D;256KB ~ &lt;&#x3D;4MB的对象。<br>大型区&#x2F;页(Large)：没有固定大小，容量可以动态变化，但是大小必须为2MB的整数倍，专门用于存放&gt;4MB的巨型对象。但值得一提的是：每个Large区只能存放一个大对象，也就代表着你的这个大对象多大，那么这个Large区就为多大，所以一般情况下，Large区的容量要小于Medium区，并且需要注意：Large区的空间是不会被重新分配的（稍后分析）。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p>作者：竹子爱熊猫<br>链接：<a href="https://juejin.cn/post/7080030329922125854">https://juejin.cn/post/7080030329922125854</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾回收</title>
      <link href="/Java/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/8da5a74db1f8/"/>
      <url>/Java/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/8da5a74db1f8/</url>
      
        <content type="html"><![CDATA[<h1 id="GC关注JVM的哪里？"><a href="#GC关注JVM的哪里？" class="headerlink" title="GC关注JVM的哪里？"></a>GC关注JVM的哪里？</h1><p>程序计数器、虚拟机栈、本地方法栈三个区域随线程而生、伴线程而亡。运行期间，栈道每个栈帧所需空间大小，其实在编译器就可大致确定，因此这几个区域的内存分配和回收都具备确定性，所分配的区域会随着线程或方法栈帧的销毁而随之回收。<br>而Java堆和元数据空间则不同，这两块区域是运行时数据区中的共享区域，并且由于多态概念的存在，在运行时，一个类不同的子类实例，所需的内存空间是不同的，也包括一个方法不同的方法版本所需的空间也是不同的，只有在运行时才能知道具体创建哪些对象，这部分区域的内存分配和回收都是动态的，GC机制关注的就是这块区域。</p><h1 id="GC如何判断存活对象？"><a href="#GC如何判断存活对象？" class="headerlink" title="GC如何判断存活对象？"></a>GC如何判断存活对象？</h1><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>很好理解，创建的每个对象都携带一个引用计数，主要用于记录自身的引用情况。当一个指针指向该当前对象时，该计数器会+1。当一个对象的计数器为0时，那么该对象会被当成“垃圾”，进行回收。</p><mark class="hl-label red">优点</mark><mark class="hl-label pink">实现简单，垃圾便于辨识，判断效率高，回收没有延迟性</mark><br /><mark class="hl-label red">缺点</mark><mark class="hl-label pink">需要额外的存储计数器，每次引用指向或者消失时都需要同步更新计数器，增加了存储成本会时间开销，最致命的一点是无法处理两个对象相互引用这种引用循环的状况</mark><p>由于相互引用导致各自的引用计数器都会为1，所以导致GC无法回收这两个对象，最终造成这两个对象所占用的空间发生内存泄漏。由于该问题的存在，所以Java并没有采用这种算法。</p><h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><p>在GC发生时，会以GC Roots作为根节点，然后从上至下的方式进行搜索分析，搜索走过的路线则被称为Reference Chain引用链。当一个对象没有任何引用链相连时，则会被判定为该对象时不可达的，即代表着此对象不可用，最终该对象会被判定为“垃圾”对象等待回收</p><h3 id="可以作为GC-Roots的对象"><a href="#可以作为GC-Roots的对象" class="headerlink" title="可以作为GC Roots的对象"></a>可以作为GC Roots的对象</h3><ul><li>虚拟机栈中引用的对象</li><li>元数据空间中类静态属性引用的对象</li><li>元空间运行时常量池中常量引用的对象</li><li>本地方法栈中JNI（native）中引用的对象</li></ul><p>除开上述中的四大类对象可以被作为根节点外，也包括被synchronized持有的对象、JVM内部的一些引用对象（如类加载器、异常类对象等）都可以作为根节点对象。</p><h3 id="可达性分析算法标记过程"><a href="#可达性分析算法标记过程" class="headerlink" title="可达性分析算法标记过程"></a>可达性分析算法标记过程</h3><p>可达性分析算法中会以GC Roots节点作为根节点向下搜索，可以被搜索到的对象则为存活对象，而当一些对象没有任何一条搜索链可以到达时，该对象则为“可回收对象”</p><h2 id="对象的finalization机制"><a href="#对象的finalization机制" class="headerlink" title="对象的finalization机制"></a>对象的finalization机制</h2><p>Java对象可触及性分为三类</p><ol><li>可触及的，存在于引用链上的对象则是可触及对象，也就是指通过根节点时可以找到的对象</li><li>可复活的，一旦当一个对象的所有引用被释放，那么它就会处于可复活状态，因为在finalize()中可能复活该对象</li><li>不可触及的，在finalize()执行后，对象会进入不可触及状态，从此该对象没有机会再次复活，只能等待被GC机制回收</li></ol><p>当垃圾回收器发现一个对象没有引用指向时，那么在GC之前，总会先调用这个对象的finalize()方法。但如果该对象所属的类没有重写finalize()方法或已经执行过一次该方法了，最终则不会再执行finalize()方法。<br>如果一个对象没了引用，但是重写了finalize()方法并且未被执行过，那么该对象会被插入到F-Queue队列中，该队列是JVM自动创建的一个队列，由低优先级的Finalizer线程执行其finalize()方法。<br>finalize()方法是一个对象实例最后的复活机会，因为GC机制会二次对F-Queue队列中的对象进行标记。如果一个对象执行finalize()方法过程中，与引用链上的任何一个对象建立了联系，那么该对象会被移出队列，然后标记为存活对象。</p><mark class="hl-label pink">1.执行过一次finalize()方法的对象再也没有机会进入到F-Queue队列中，当执行过一次之后finalize()方法不会再次被调用，对象会直接变成不可触及的状态。</mark><br /><mark class="hl-label pink">2.finalize()方法的执行具备不确定性，JVM只会保证对象的finalize()方法会调用，但不保证finalize()方法100%能执行完毕。比如此时，Finalizer线程正在执行一个对象finalize()方法，但是其内部的逻辑执行比较耗时，而此时堆内存严重不足（已用内存达到98%以上）时，GC会强制回收掉该队列中的对象。也就相当于finalize()方法本来是对象的最后抢救机会，结果抢救过程中因为某些意外因素，对象直接结束了。</mark><h1 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h1><p>垃圾回收算法一般在堆可用内存不足的情况下会被触发，通常来说，它们首先会先停止应用程序（STW：Stop The World），也就是将JVM中所有的用户线程暂停，这样可以保持堆内存在该时间段内不会发生新的变化，能够在最大程度上保证结果的准确性。</p><h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><p>在标记阶段会根据可达性分析算法，通过根节点标记堆中所有的可达对象，而这些对象则称为堆中存活对象，反之，未被标记的则为垃圾对象。在清除阶段，会对于所有未标记的对象进行清除。同时为了方便下次GC，在清除操作完成之后，会将前面存活对象的GC标志位复位，也就是会将标记从1还原成为标记的0<br>标记-清除算法是最初的GC算法，因为在标记阶段需要停下所有用户线程，也就是发生STW，而标记的时候又需要遍历整个堆空间中的所有GcRoots，所以耗时比较长，对于客户端而言，可能会导致GC发生时，造成很长一段时间内无响应。同时，因为堆空间中的垃圾对象是会分散在内存的各个角落，所以一次GC之后，会造成大量的内存碎片，也就是通过标-清算法清理出来的内存是不连续的，为了解决这个问题，JVM就不得不再额外维持一个内存的空闲列表，这又是一种开销。而且在分配数组对象或大对象时，连续的内存空间资源又会变得很匮乏。</p><h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><p>复制算法与前面的标-清算法相比，它就可以很好的保证内存回收之后的内存整齐度。因为复制算法会将JVM中原有的堆内存分为两块，在同一时刻只会使用一块内存用于对象分配。在发生GC时，首先会将使用的那块内存区域中的存活对象复制到未使用的这块内存中。等复制完成之后，对当前使用的这块内存进行全面清除回收，清除完成之后，交换两块内存之间的角色，最后GC结束。<br>由于每次GC都是直接对半边区域进行回收，所以回收之后不需要考虑内存碎片的复杂情况，在内存分配时直接可以使用简单高效的<code>指针碰撞</code>方式分配对象。<br>但这种算法最大的问题在于对内存的浪费，因为在实际内存分配时只会使用一块内存，所以在实际分配时，内存直接缩水一半，这是比较头疼的事情。同时，存活的对象在GC发生时，还需要复制到另一块内存区域，因此对象移动的开销也需要考虑在内，所以想要使用这种算法，最起码对象的存活率要非常低才行。</p><h2 id="标记-整理算法-标记-压缩算法"><a href="#标记-整理算法-标记-压缩算法" class="headerlink" title="标记-整理算法(标记-压缩算法)"></a>标记-整理算法(标记-压缩算法)</h2><p>标-整算法适用于存活率较高的场景（适合于老年代），它是建立在标-清算法的基础上做了优化。标-整算法也会分为两个阶段，分别为标记阶段、整理阶段：</p><mark class="hl-label pink">标记阶段：和标-清算法一样。在标记阶段时也会基于GcRoots节点遍历整个内存中的所有对象，然后对所有存活对象做一次标记。</mark><br /><mark class="hl-label pink">整理阶段：在整理阶段该算法并不会和标-清算法一样简单的清理内存，而是会将所有存活对象移动（压缩）到内存的一端，然后对于存活对象边界之外的内存进行统一回收。</mark><p>经过标-整算法之后的堆空间会变成整齐的内存，因为被标记为存活的对象都会被压缩到内存的一端。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，也就是保留一根指针指向已用内存和空闲内存的分割点，也就是可以直接采用指针碰撞的方式进行内存分配，这比维护一个空闲列表显然少了许多开销。</p><h1 id="垃圾收集算法总结"><a href="#垃圾收集算法总结" class="headerlink" title="垃圾收集算法总结"></a>垃圾收集算法总结</h1><ul><li>收集速度：复制算法 &gt; 标-清算法 &gt; 标-整算法</li><li>内存整齐度：复制算法 &#x3D; 标-整算法 &gt; 标-清算法</li><li>内存利用率：标-整算法 &gt; 标-清算法 &gt; 复制算法</li></ul><h2 id="分代收集策略"><a href="#分代收集策略" class="headerlink" title="分代收集策略"></a>分代收集策略</h2><p>新生代：一般使用复制算法，因为在新生代中的对象几乎绝大部分都是朝生夕死的，每次GC发生后只会有少量对象存活，这种情况下采用复制算法无疑是个不错的选择，付出一定的内存空间开销以及少量存活对象的移动开销，换取内存的整齐度以及可观收集效率，这很明显是个“划得来的买卖”。<br>年老代：一般采用标-整算法或标-清算法，但绝大多数年老代GC器都会选择采用标-整算法，因为毕竟标-清算法会导致大量的内存碎片产生，在年老代对象分配时，内存不完整可能会导致大对象分配不下而持续触发GC。而标-整算法虽然效率较低，但胜在GC后内存足够整齐，再加上年老代的GC并没有新生代频繁，所以年老代空间采用标-整算法无疑也是个不错的选择。</p><h2 id="分区收集策略"><a href="#分区收集策略" class="headerlink" title="分区收集策略"></a>分区收集策略</h2><p>在JDK1.8及之前的JVM中，堆中间一般会按照对象的生命周期长短划分为新生代、年老代两个空间，分别用于存储不同周期的对象。而在新版本的GC器，如G1、ZGC中，则摒弃了之前物理内存上分代的思想，在运行时并不会直接将堆空间切分为两块区域，而是将整个堆划分为连续且不同的小区间，每一个小区间都独立使用，独立回收，这种回收策略带来的好处是：可以控制一次回收多少个小区间。</p><h1 id="STW-Stop-The-World"><a href="#STW-Stop-The-World" class="headerlink" title="STW Stop The World"></a>STW Stop The World</h1><h2 id="为什么要在GC的时候STW"><a href="#为什么要在GC的时候STW" class="headerlink" title="为什么要在GC的时候STW"></a>为什么要在GC的时候STW</h2><ol><li>尽量避免浮动垃圾的产生</li><li>确保一致性：在整个分析期间，JVM看起来就像被冻结在某个时间点上，不可以出现分析过程中对象引用关系还在不断变化的情况</li></ol><h2 id="STW带来的问题"><a href="#STW带来的问题" class="headerlink" title="STW带来的问题"></a>STW带来的问题</h2><ul><li>客户端长时间无响应问题</li><li>HA系统中的主从切换脑裂问题：如果主机触发GC发生STW，最终造成主机长时间停顿，而备机会监测到主机没有工作，于是备机开始尝试将流量切换到自身来处理，从备机变为了主机。但旧主不工作只是暂时的，因为GC的原因导致暂停一段时间，而当GC完成后，旧主会依旧开始工作，最终造成了整个HA系统中出现了双主情况，形成了脑裂问题，最终影响生产环境。</li><li>上游系统宕机问题：如果当某个工程所在的机器发送GC出现STW时，那么上游系统过来的请求则不会处理，如果STW时间一长，最终很有可能导致上游机器扛不住流量而出现宕机。</li></ul><h1 id="GC类型划分"><a href="#GC类型划分" class="headerlink" title="GC类型划分"></a>GC类型划分</h1><ul><li>新生代收集（MinorGC&#x2F;YoungGC）：只针对新生代的GC，当Eden区满了时触发，Survivor满了并不会触发。</li><li>年老代收集（MajorGC&#x2F;OldGC）：针对年老代空间的GC，不过目前只有CMS存在单独回收年老代的行为。</li><li>混合收集（MixedGC）：指收集范围覆盖<strong>整个新生代空间及部分年老代空间</strong>的GC，目前只有G1存在该行为。</li><li>全面收集(FullGC)：覆盖新生代、年老代以及元数据空间的GC，会对于所有可发生GC的内存进行收集。以下是触发FullGC的原因<ul><li>调用System.gc()时，JVM在内存占用较多时会尝试发生FullGC，但并非100%触发。</li><li>除CMS之外收集器，当年老代不足时也会触发FullGC。</li><li>元数据空间内存不足时，也会触发FullGC。</li><li>对象晋升时年老代空间无法承载晋升对象时也会触发FullGC。</li><li>新生代空间分配担保机制触发时，也会先触发FullGC。<br>JVM空间分配担保策略：确保在Minor GC时，存活的对象能够成功晋升到老年代。如果老年代没有足够的空间来接收新晋升的对象，JVM可能会提前触发一次Full GC来释放空间，或者调整自己的内存分配策略以避免此类情况的发生</li></ul></li></ul><h1 id="安全点好安全区域"><a href="#安全点好安全区域" class="headerlink" title="安全点好安全区域"></a>安全点好安全区域</h1><p>当用户线程执行到安全点或安全区域的代码处，此时发生停止是安全的，后续再次唤醒线程工作时，执行结果也不会因为线程暂停而受到任何影响。</p><h2 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h2><p>当我们需要阻塞停止一条线程时，都需要在安全点停止，简单说安全点就是指当线程运行到这类位置时，堆对象状态是确定一致的，线程停止后，JVM可以安全地进行操作，如GC、偏向锁撒销等。<br>JVM对安全点的定义</p><ul><li>循环结束的末尾段</li><li>方法调用之后</li><li>抛出异常的位置</li><li>方法返回之前<br>当JVM需要发生GC、偏向锁撤销等操作时，如何才能让所有线程到达安全点阻塞或停止？</li><li>主动式中断(JVM采用的方式)：不中断线程，而是设置一个标志，而后让每条线程执行时主动轮询这个标志，当一个线程到达安全点后，发现中断标志为true时就自己中断挂起。</li><li>抢断式中断：先中断所有线程，如果发现线程未执行到安全点则恢复线程让其运行到安全点位置。</li></ul><h2 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h2><p>当Java程序需要停下所有用户线程时，某些线程可能处于中断或者休眠状态，从而无法响应JVM的中断请求走到安全点位置挂起了，所以出现了安全区域的概念。<br>安全区域是指一条线程执行到一段代码时，该区域的代码不会改变堆中对象的引用。在这区域内JVM可以安全地进行操作。当线程进入到该区域时需要先标识自己进入了，这样GC线程则不会管这些已标识的线程，当线程要离开这个区域时需要先判断可达性分析是否完成，如果完成了则往下执行，如果没有则需要原地等待到GC线程发出安全离开信息为止。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://juejin.cn/post/7065948181346910239">https://juejin.cn/post/7065948181346910239</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode</title>
      <link href="/%E7%AE%97%E6%B3%95/algorithm/leetcode/8023b8741d45/"/>
      <url>/%E7%AE%97%E6%B3%95/algorithm/leetcode/8023b8741d45/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode-1745"><a href="#leetcode-1745" class="headerlink" title="leetcode 1745"></a>leetcode 1745</h1><p>给你一个字符串<code>s</code>，如果可以将它分割成三个<code>非空</code>回文子字符串，那么返回<code>true</code>，否则返回<code>false</code>。</p><mark class="hl-label red">思路：</mark><mark class="hl-label pink">由于需要分割为三个非空子字符串，那么可以从第一个字符和最后一个字符下手，我们可以记录下来，以第一个字符开头的回文字符串，以最后一个字符结尾的回文字符串，然后再判断中间的字符串是否是回文字符串，由于分割非空的要求，需要保证中间的字符串存在。</mark><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">checkPartitioning</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    n = <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="comment"># dp[i][j] 表示 s[i...j] 的字符串是否是回文字符串</span></span><br><span class="line">    dp = [[<span class="literal">True</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, n):</span><br><span class="line">            dp[i][j] = (s[i] == s[j]) &amp; dp[i+<span class="number">1</span>][j-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># start[] 表示以第一个字符开头，数组的值为回文字符串结尾的下标</span></span><br><span class="line">    start = []</span><br><span class="line">    <span class="comment"># end[] 表示以最后一个字符结尾，数组的值为回文字符串开头的下标</span></span><br><span class="line">    end = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n-<span class="number">1</span>):</span><br><span class="line">        t = s[:i]</span><br><span class="line">        <span class="keyword">if</span> t == t[::-<span class="number">1</span>]:</span><br><span class="line">            start.append(i-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">        t = s[i:]</span><br><span class="line">        <span class="keyword">if</span> t == t[::-<span class="number">1</span>]:</span><br><span class="line">            end.append(i)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 注意 start 和 end都为有序，start从小到大，end从大到小</span></span><br><span class="line">    <span class="keyword">for</span> part1 <span class="keyword">in</span> start:</span><br><span class="line">        <span class="keyword">for</span> part2 <span class="keyword">in</span> end:</span><br><span class="line">            <span class="comment"># 如果中间没有字符串了，则直接跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> part1 + <span class="number">1</span> &gt;= part2:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 查看中间的字符串是否回文，如果回文，则说明可以分割为3个非空回文子字符串</span></span><br><span class="line">            <span class="keyword">if</span> dp[part1+<span class="number">1</span>][part2-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/Redis/Redis/redis/802e96468d9a/"/>
      <url>/Redis/Redis/redis/802e96468d9a/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分库分表</title>
      <link href="/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/61d9fe25d01b/"/>
      <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/61d9fe25d01b/</url>
      
        <content type="html"><![CDATA[<p>阿里巴巴Java开发手册：<strong>单表行数超过500万行或者单表容量超过20GB，才推荐进行分表分库</strong></p><h1 id="为什么需要分表分库"><a href="#为什么需要分表分库" class="headerlink" title="为什么需要分表分库"></a>为什么需要分表分库</h1><ol><li>请求数太高</li><li>数据查询慢</li><li>数据量太大</li><li>单体架构：某张表遇到问题需要修复时，会影响整个库中的所有数据</li><li>MySQL的数据库瓶颈</li></ol><p>分库和分表是两个概念</p><h1 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h1><h2 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h2><p>结构不同，数据不同。<br>现在有一张表，总共43个字段，但是对于程序来说，一般经常使用的字段不过其中的十余个，而这些经常使用的字段则被称之为热点字段，假设此时这张表中的热点字段为18个，剩下的冷字段为25个，那么我们就可以根据冷热字段来对表进行拆分，拆分为18个字段一张表，26个字段一张表（含有一个映射键）</p><h2 id="水平分表"><a href="#水平分表" class="headerlink" title="水平分表"></a>水平分表</h2><p>结构相同，数据不同<br>现在有一张表，里面有三千万条数据记录，当基于该表去执行一条在索引上的复杂SQL时，也需要一定时间，至少会比1000万的数据表慢了好几倍，此时可以把这张3000W的表，拆为三张1000W的表。<br>对一张大表做了水平分表之后，咱们能够很好的控制单表的数据行数，3000W条数据的表和1000W条数据的表，查询速度其实不仅仅只是3倍的差距，数据过了千万级别时，数据量每向上增长一个量级，查询的开销也会呈直线性增长，因此做水平分表时，一般要求控制在500-1200W之间为一张表（阿里500-600w一张）。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>分表方案主要是针对单表字段过多或数据过多进行设计的，无论是垂直分表还是水平分表，都必须建立在单库压力不大，但是单表性能不够的情况下进行的</p><h1 id="分库"><a href="#分库" class="headerlink" title="分库"></a>分库</h1><h2 id="垂直分库"><a href="#垂直分库" class="headerlink" title="垂直分库"></a>垂直分库</h2><p>结构不同，数据不同<br>垂直分库，就是根据业务属性的不同，将单库中具备同一业务属性的表，全部单独拧出来，放在一个单独的库中存储，也就按业务特性将大库拆分为多个业务功能单一的小库，每个小库只为对应的业务提供服务，这样能够让数据存储层的吞吐量呈几何倍增长。</p><h2 id="水平分库"><a href="#水平分库" class="headerlink" title="水平分库"></a>水平分库</h2><p>结构相同，数据不同<br>经过垂直分库后，根据不同的业务类型，将访问压力分发到不同的库处理后，虽然在极大程度上提升了数据层的负荷能力，但如果某类业务的并发数依旧很高。通过水平拆分的方案，能够根据压力的不同，分配不同的机器数量，从而使得不同库的抗压性都能满足对应的业务需求，这也就类似于分布式&#x2F;微服务项目中，对单个服务做集群保证高可用的策略。<br>水平分库是基于一个节点，然后直接横向拓展，这也就意味着同一业务的数据库，各节点之间的库结构完全相同，但每个节点中的数据是否相同，这就要看你自己去决定了，一般情况下都是不同的，也就是不同节点的库会存储不同范围的数据。</p><h2 id="其他分库方案"><a href="#其他分库方案" class="headerlink" title="其他分库方案"></a>其他分库方案</h2><p><strong>主从方案&#x2F;读写分离</strong>，写请求发往主节点，读请求发往从节点<br><strong>多主方案</strong>，一般是双主方案</p><h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p>对于分库方案</p><ol><li>优先考虑主从，主主</li><li>再考虑垂直分库</li><li>最后考虑水平分库</li></ol><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://juejin.cn/post/7168355448658395166#heading-22">https://juejin.cn/post/7168355448658395166#heading-22</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/uncategorized/hello-world/78086a1524d6/"/>
      <url>/uncategorized/hello-world/78086a1524d6/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>表分区</title>
      <link href="/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E8%A1%A8%E5%88%86%E5%8C%BA/880c80509e5a/"/>
      <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E8%A1%A8%E5%88%86%E5%8C%BA/880c80509e5a/</url>
      
        <content type="html"><![CDATA[<h1 id="表分区的介绍"><a href="#表分区的介绍" class="headerlink" title="表分区的介绍"></a>表分区的介绍</h1><p>原本的表文件都是以完整的形式存储在磁盘中的，而表分区则是指将一张表的数据拆分成多个磁盘文件，然后放到磁盘中存储。<br>需要去检索一条数据时，无需对一个完整的数据文件从头到尾做扫描，而只需要对某个分区文件进行扫描，能够在一定程度上提高性能。</p><ul><li>相较于使用单个文件存储表数据，表分区技术可以打破单个磁盘分区的容量限制。</li><li>对于一些失效数据，如三年前的数据，可以通过快速删除分区的方式清理，效率十分高。</li><li>能够在一定程度上提升磁盘IO时，检索数据的性能，毕竟只需对一小片磁盘表文件做寻道。</li><li>支持聚合函数的并行执行，比如sum()、count()这类函数，可以分别统计各分区的数据做汇总。</li><li>带来更好的数据管理性和可用性，当一个表文件受损时，不会影响其他分区文件中的表数据。</li></ul><p>表分区只支持水平划分！！！</p><h1 id="表分区的方式"><a href="#表分区的方式" class="headerlink" title="表分区的方式"></a>表分区的方式</h1><h2 id="RANGE分区"><a href="#RANGE分区" class="headerlink" title="RANGE分区"></a>RANGE分区</h2><p>按范围进行分区</p><h2 id="LIST分区"><a href="#LIST分区" class="headerlink" title="LIST分区"></a>LIST分区</h2><p>枚举分区，为每个分区分配指定值，比如按照性别，男生一个分区，女生一个分区</p><h2 id="HASH分区"><a href="#HASH分区" class="headerlink" title="HASH分区"></a>HASH分区</h2><ol><li>常规哈希：基于某个整数型字段，直接做取模，最后根据余数来决定数据的分区。</li><li>线性哈希：基于某个字段哈希之后的哈希值，进行取模运算，最后根据余数来决定数据的分区。</li></ol><h2 id="KEY分区"><a href="#KEY分区" class="headerlink" title="KEY分区"></a>KEY分区</h2><ul><li>表中只存在主键或唯一字段时，分区键必须为主键&#x2F;唯一键的部分或全部字段，不允许选择其他字段。</li><li>表中主键、唯一字段同时存在时，分区键必须为主键和唯一键共有的部分或全部字段。</li><li>当表中不存在主键或唯一键时，分区键可以是除text、blob类型外的任意单个或多个字段。</li></ul><h2 id="SUB分区"><a href="#SUB分区" class="headerlink" title="SUB分区"></a>SUB分区</h2><p>基于表分区的结果进一步做分区处理</p><h2 id="COLUMNS分区"><a href="#COLUMNS分区" class="headerlink" title="COLUMNS分区"></a>COLUMNS分区</h2><p>使得range、list分区由多个字段组成，同时支持的字段类型也相对丰富</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://juejin.cn/post/7166500122166034469">https://juejin.cn/post/7166500122166034469</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>juc</title>
      <link href="/Java/JUC/juc/e836a6b7c744/"/>
      <url>/Java/JUC/juc/e836a6b7c744/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
